<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WS6</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h1 id="workshop-6">Workshop 6</h1>
<p>Dans ce workshop, il est proposé de mettre en oeuvre une pile, une file et un arbre. Au terme du temps alloué, il est demandé, de traiter l’ensemble des exercices proposés. Pour chaque exercice vous implémenterez une fonction de test des composants logiciels développés. Suivez les questions pas-à-pas. La résolution des exercices proposés nécessite de la reflexion, ne vous contentez pas uniquement de recherches sur le Web.</p>
<h1 id="structures-de-données">Structures de données</h1>
<p>On appelle structure de données, l’organisation du stockage des données dans un programme. Parmi les plus usitées en programmation citons : les types primitifs (e.g. entiers, flottants, caractères, etc.), les types composés (e.g. les tableaux, les vecteurs, etc.), les types de données abstraits (e.g. les listes, les piles, les files, les arbres, les graphes, les tables de hachage, etc). Les algorithmes tirent généralement parti de l’agencement mémoire particulier qu’impose l’utilisation d’une structure de données, à des fins d’efficacité. Par exemple, un algorithme supprimant des éléments d’une séquence (i.e. une suite d’éléments ordonnés), aura éventuellement interêt à s’appuyer sur l’utilisation de listes chaînées. Afin d’être efficaces, certains algorithmes de recherche de motifs dans une chaîne de caractères s’appuient sur l’utilisation d’arbres de suffixes.</p>
<h1 id="les-tableaux-dynamiques">Les tableaux dynamiques</h1>
<p>Les tableaux dynamiques sont des structures de données classiques étendant l’applicabilité des  tableaux classiques auxquels sont affectés des zones mémoire figées pour toute la durée de vie du programme. La mémoire affectée à un tableau dynamique est redimensionnable selon le besoin en capacité de stockage. Typiquement un tableau dynamique occupe une zone mémoire contigüe allouée avec la primitive <code>malloc</code>. La primitive <code>realloc</code> est employée si le besoin de redimensionner un tableau dynamique se manifeste. L’algorithme implémenté par la fonction <code>realloc</code> n’est pas anodin et nécessite quelques précautions. En effet, le pointeur retourné peut différer entre deux appels successifs de <code>realloc</code>. Aussi, deux situations se posent. Soit, la demande de réallocation induit une occupation mémoire moindre et <code>realloc</code> se charge de trouver un bloc mémoire inoccupé plus petit pour éviter la fragmentation. Soit la demande de réallocation nécessite davantage de mémoire et dans ce cas <code>realloc</code> peut être amené à rechercher un nouveau bloc mémoire inoccupé plus grand.</p>
<h2 id="exercice-1">Exercice 1</h2>
<p>Dans une fonction, en dehors de toute classe, implémenter un tri par insertion reposant sur l’utilisation de <code>std::vector</code>. L’objectif est de simuler l’arrivée de nouveaux éléments dans un vecteur déjà trié. La validation de votre code sera assurée par l’insertion d’éléments dans un tableau trié. L’algorithme du tri par insertion est le suivant :</p>
<pre><code>Fonction tri_insertion(l: liste d'entiers, n: entier):
	Pour i allant de 1..n - 1:
        v = l[i]
        j = i
        Tant que (j &gt; 0 et l[j - 1] &gt; v):
            l[j] = l[j - 1]
            j = j - 1
        Fin
        l[j] = v
    Fin
Fin
</code></pre>
<h1 id="les-tables-de-hachage">Les tables de hachage</h1>
<p>Les tables de hachage sont des structures de données capables de référencer rapidement un objet stocké par le biais d’une fonction de hachage. La clé de hachage permet d’indexer rapidement un élément d’une table de hachage, via un couple <code>(clé, valeur)</code>. Il faut cependant noter qu’en cas de collision de la clé de hachage avec d’autres valeurs du tableau, l’élément effectivement indexé est récupéré via une recherche séquentielle. Ces structures de données fournissent un mécanisme capable d’indexer des valeurs en temps constant après amortissement. En C++, une structure de données de type table de hachage est fournie par le conteneur <code>std::unordered_map</code>.</p>
<h2 id="exercice-1--éviter-les-redondances">Exercice 1 : éviter les redondances</h2>
<p>Implémenter une classe <code>UniqueList</code> dont l’objectif est de maintenir l’unicité des éléments insérés dans une liste. Pour aboutir, nous utiliserons une table de hachage afin de déterminer efficacement la présence ou non d’un objet. Il s’agira de conserver une liste d’entiers dans un conteneur de type <code>std::vector</code>. A chaque ajout d’un nouvel entier en fin de tableau, la présence d’un doublon est vérifiée par l’interrogation d’un objet <code>std::unordered_map</code>. Le cas échéant, l’insertion échoue. Pour aboutir les contraintes suivantes devront être respectées :<br>
-  Utiliser une liste <code>std::vector&lt;int&gt;</code> pour stocker des entiers.<br>
-  Utiliser une table de hachage <code>std::unordered_map&lt;int, bool&gt;</code> pour suivre la présence des entiers dans le vecteur.<br>
- Implémenter une méthode <code>bool hasValue(int val)</code> pour vérifier la présence de l’entier <code>val</code> dans la liste.<br>
- Implémenter une méthode <code>bool add(int val)</code> pour ajouter un entier à la liste s’il n’est pas déjà présent.<br>
- Implémenter une méthode <code>bool remove(int val)</code> pour supprimer un entier de la liste s’il est présent.<br>
- Implémenter une méthode <code>print()</code> pour afficher le contenu du vecteur.</p>
<h2 id="exercice-2--fonction-de-transition">Exercice 2 : Fonction de transition</h2>
<p>Nous souhaitons implémenter un automate <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">A</mi></mrow><annotation encoding="application/x-tex">\mathcal{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathcal">A</span></span></span></span></span> doté d’un ensemble d’états tel que <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mi>i</mi></msub><mo>∈</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">E_i \in E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span style="margin-right: 0.05764em;" class="mord mathnormal">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.05764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05764em;" class="mord mathnormal">E</span></span></span></span></span> engendrant chacun une action spécifique. Un changement d’état est opéré par une fonction de transition bijective notée <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>:</mo><mi>E</mi><mo>→</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">δ: E \rightarrow E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.03785em;" class="mord mathnormal">δ</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05764em;" class="mord mathnormal">E</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05764em;" class="mord mathnormal">E</span></span></span></span></span>. A partir d’un état il est alors possible d’aboutir à l’état suivant selon les règles suivantes :</p>
<ul>
<li>δ(<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">E_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span style="margin-right: 0.05764em;" class="mord mathnormal">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.05764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>) = <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">E_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span style="margin-right: 0.05764em;" class="mord mathnormal">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.05764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span></li>
<li>δ(<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">E_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span style="margin-right: 0.05764em;" class="mord mathnormal">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.05764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>) = <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">E_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span style="margin-right: 0.05764em;" class="mord mathnormal">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.05764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span></li>
<li>δ(<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">E_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span style="margin-right: 0.05764em;" class="mord mathnormal">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.05764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>) = <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">E_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span style="margin-right: 0.05764em;" class="mord mathnormal">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.05764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span></li>
<li>δ(<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">E_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span style="margin-right: 0.05764em;" class="mord mathnormal">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.05764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>) = <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span></span></li>
</ul>
<p>Implémenter ce fonctionnement via l’utilisation d’une table de hachage <code>std::map</code>. Pour aboutir les étapes suivantes seront à mener à bien :</p>
<ul>
<li>Utiliser une énumération <code>enum stateId</code> pour définir les identifiants des états.</li>
<li>Définir une classe abstraite <code>AbstractState</code> représentant un état et doté d’une méthode virtuelle pure <code>action()</code> qui sera redéfinie dans les classes dérivées pour chaque état spécifique.</li>
<li>Chaque état sera représenté par une classe spécifique dérivée de <code>AbstractState</code>. Il s’agira simplement d’afficher une chaîne de caractère pour matérialiser l’action associée à un état.</li>
<li>Créer une classe <code>Automata</code> gérant les transitions entre états. Elle contient une map dénommée <code>delta</code> qui définit la fonction de transition <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.03785em;" class="mord mathnormal">δ</span></span></span></span></span>.
<ul>
<li>La méthode <code>initAutomata()</code> initialise l’automate avec les états et leurs transitions.</li>
<li>La méthode <code>transition()</code> met à jour l’état actuel en utilisant la map <code>delta</code>.</li>
<li>La méthode <code>action()</code> exécute l’action associée à l’état actuel.</li>
<li>La méthode <code>run()</code> exécute l’automate jusqu’à atteindre l’état final (<code>NULL</code>).</li>
</ul>
</li>
</ul>
<h1 id="la-pile">La pile</h1>
<p>Une pile est une structure de données de type Dernier-Entré-Premier-Sorti (DEPS) ou Last-In-First-Out (LIFO) en anglais. En informatique cette structure de données revêt un intérêt fondamental. Elle autorise par exemple un programme à appeler des fonctions, et à leur terminaison, de poursuivre l’exécution des instructions suivantes. On défini communément les opérations push et pop, dont la sémantique respective est d’empiler/dépiler des éléments sur/de la pile. Voici les cas d’utilisation les plus fréquents des piles :</p>
<ul>
<li>Comme évoqué précédemment, la pile d’exécution (ou pile implicite) autorise un programme à appeler des fonctions et de sauvegarder l’adresse de retour afin de poursuivre le flot d’exécution.</li>
<li>Certaines architectures (e.g. CUDA pour les architectures GPU antérieures à Fermi) ne supportent pas les appels récursifs. On transforme alors généralement un programme exprimé de manière récursive en une forme itérative, moyennant éventuellement l’utilisation d’une pile explicite. Par pile explicite est entendu la mise en œuvre de ladite structure de données par le programmeur lui-même.</li>
<li>En compilation l’étape d’analyse syntaxique (e.g. parsing) du code source repose principalement sur l’utilisation de piles.</li>
<li>Les piles sont employées de façon explicite pour palier aux limitations de mémoire de la pile d’exécution.<br>
En C++, une structure de données de type pile est fournie par le conteneur <code>std::stack</code>.</li>
</ul>
<h2 id="exercice-1--représentation-en-base-b">Exercice 1 : représentation en base <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathnormal">b</span></span></span></span></span></h2>
<p>Créer une classe <code>ChangeBase</code> dotée de méthodes de conversion d’un entier <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">n \in \mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.68889em; vertical-align: 0em;"></span><span class="mord mathbb">N</span></span></span></span></span> exprimé en base <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">10</span></span></span></span></span> vers une base <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>∈</mo><mo mathvariant="normal" lspace="0em" rspace="0em">⟦</mo><mn>1</mn><mo separator="true">,</mo><mn>10</mn><mo mathvariant="normal" lspace="0em" rspace="0em">⟧</mo></mrow><annotation encoding="application/x-tex">b \in \llbracket 1, 10 \rrbracket</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.73354em; vertical-align: -0.0391em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen"><span class="mopen">[</span><span class="mspace" style="margin-right: -0.177778em;"></span><span class="mopen">[</span></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">10</span><span class="mclose"><span class="mclose">]</span><span class="mspace" style="margin-right: -0.177778em;"></span><span class="mclose">]</span></span></span></span></span></span> à l’aide d’une pile. Pour ce faire rajouter la méthode <code>std::stack&lt;int&gt; toBase(int n, int b);</code>. Une autre méthode <code>void print();</code> s’occupera d’afficher le résultat obtenu après changement de base. Dites pourquoi il est intéressant d’utiliser une pile dans ce cas. Rappel de l’algorithme de conversion :</p>
<pre><code>Fonction toBase(n: entier, b: entier): //precondition : n &gt; 0, b &gt; 0, b &lt;= 10
        i = 1
        c = 0
        Tant que n != 0:
            c = c + i * (n % b)
            n = n / b
            i *= 10
        Fin
        Retourner c
    Fin
</code></pre>
<h2 id="exercice-2--quoi--encore-du-tri-">Exercice 2 : quoi ? encore du tri ?</h2>
<p>Nous souhaitons trier une série d’entiers insérés dans un tableau. Afin de parvenir à notre but l’idée est de mettre en oeuvre deux piles. Soit, par exemple le tableau d’entiers <code>[1, 11, 3, 7, 5]</code>, les traitements suivants seront opérés pour aboutir au résultat :</p>
<ol>
<li><code>in = ?, origStack = [1, 11, 3, 7, 5], ordStack = []</code></li>
<li><code>in = 5, origStack = [1, 11, 3, 7], ordStack = [5]</code></li>
<li><code>in = 7, origStack = [1, 11, 3], ordStack = [5, 7]</code></li>
<li><code>in = 3, origStack = [1, 11, 7, 5], ordStack = [3]</code></li>
<li><code>in = 3, origStack = [1, 11], ordStack = [3, 5, 7]</code></li>
<li><code>in = 11, origStack = [1, 11], ordStack = [3, 5, 7, 11]</code></li>
<li><code>in = 1, origStack = [11, 7, 5, 3], ordStack = [1]</code></li>
<li><code>in = 1, origStack = [], ordStack = [1, 3, 5, 7, 11]</code></li>
</ol>
<ul>
<li>Analyser le fonctionnement de l’algorithme ci-dessus. Que se passe-t-il à l’étape <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">4</span></span></span></span></span> ? Quand l’algorithme se termine-t-il ?</li>
<li>Proposer une implémentation de l’algorithme avec <code>std::stack</code> pour aboutir à un tri croissant.</li>
<li>Créer une classe <code>SortedList</code> qui encapsule une séquence d’entiers triés et stockés dans une pile. Y seront intégrés les éléments suivants :
<ul>
<li>Un attribut de type <code>std::stack</code> pour stocker la liste triée.</li>
<li>Un constructeur paramétré par une liste d’entiers non triés  de type <code>std::vector</code>.</li>
<li>Une méthode <code>sort()</code> implémentant l’algorithme de tri.</li>
<li>Une méthode <code>print()</code> pour afficher le contenu de la liste triée.</li>
</ul>
</li>
<li>Comment le principe d’encapsulation est-il ici mis en exergue ?</li>
</ul>
</div>
</body>

</html>
